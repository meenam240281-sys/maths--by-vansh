<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maths Solver with Custom Keyboard</title>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/algebra.js/0.2.6/algebra.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nerdamer/1.1.13/nerdamer.core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nerdamer/1.1.13/Algebra.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nerdamer/1.1.13/Calculus.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nerdamer/1.1.13/Solve.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f7f9fc;
    }

    header {
      background: #2b2d42;
      color: white;
      text-align: center;
      padding: 1rem;
    }

    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
    }

    textarea {
      width: 100%;
      height: 60px;
      font-size: 18px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #ccc;
      margin-bottom: 10px;
      resize: vertical;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      margin-right: 10px;
      margin-top: 10px;
      cursor: pointer;
      border: none;
      border-radius: 6px;
      background: #2b2d42;
      color: white;
      transition: 0.3s;
    }

    button:hover {
      background: #4a4e69;
    }

    .output {
      background: white;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      font-size: 18px;
      min-height: 50px;
    }

    .note {
      margin-top: 20px;
      font-size: 14px;
      color: #444;
      background: #e9ecef;
      padding: 10px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Universal MathSolver</h1>
    <p>Solve equations, algebra, calculus, complex numbers, and more</p>
  </header>

  <div class="container">
    <!-- Input field linked with keyboard.html -->
    <textarea id="expression" placeholder="Type your math expression here..."></textarea>
    <br>
    <button onclick="solveExpression()">Solve</button>
    <button onclick="clearOutput()">Clear</button>

    <div class="output" id="output">Result will appear here...</div>

    <div class="note">
      <b>Note:</b> Use brackets for clarity if possible.  
      Example: (2/3)x instead of 2/3x.  
      Solver will try to auto-correct missing brackets and formats.  
    </div>
  </div>
  <script>
    // Preprocess input before solving
    function preprocessInput(expr) {
      let cleaned = expr
        .replace(/\s+/g, "")         // remove spaces
        .replace(/÷/g, "/")          // division sign
        .replace(/×/g, "*")          // multiplication sign
        .replace(/√/g, "sqrt")       // square root
        .replace(/∛/g, "cbrt")       // cube root
        .replace(/π/g, "pi")         // pi constant
        .replace(/θ/g, "theta");     // theta variable

      // Handle implicit multiplication: 2x → 2*x
      cleaned = cleaned.replace(/(\d)([a-zA-Z])/g, "$1*$2");
      cleaned = cleaned.replace(/([a-zA-Z])(\d)/g, "$1*$2");

      // Replace power symbols
      cleaned = cleaned.replace(/\^/g, "**");

      // Ensure equality symbol is consistent
      cleaned = cleaned.replace(/==/g, "=");

      return cleaned;
    }

    function solveExpression() {
      const expr = document.getElementById("expression").value;
      const outputDiv = document.getElementById("output");

      if (!expr.trim()) {
        outputDiv.innerHTML = "⚠️ Please enter an expression.";
        return;
      }

      let processed = preprocessInput(expr);
      let result = "";

      try {
        // Case 1: Equation (with '=' sign)
        if (processed.includes("=")) {
          let [lhs, rhs] = processed.split("=");
          let eqn = lhs + "-(" + rhs + ")";
          let sol = nerdamer.solveEquations(eqn);
          result = "<b>Equation:</b> " + expr + "<br>" +
                   "<b>Solution:</b> " + JSON.stringify(sol);
        }

        // Case 2: General expression
        else {
          let evalResult = math.evaluate(processed);

          // Try algebra.js simplification
          try {
            let algebraExpr = algebra.parse(processed);
            evalResult = algebraExpr.toString();
          } catch (err) {
            // fallback to math.js result
          }

          result = "<b>Expression:</b> " + expr + "<br>" +
                   "<b>Result:</b> " + evalResult;
        }
      } catch (error) {
        result = "❌ Invalid input. Please check your expression.";
      }

      outputDiv.innerHTML = result;
    }

    function clearOutput() {
      document.getElementById("expression").value = "";
      document.getElementById("output").innerHTML = "Result will appear here...";
    }
</script>
<script>
    // ---------- Advanced normalization helpers ----------
    function normalizeNaturalLanguage(s) {
      // common word forms -> symbols
      s = s.replace(/is equal to/ig, '=')
           .replace(/\bequals\b/ig, '=')
           .replace(/\beq\b/ig, '=')
           .replace(/divided by/ig, '/')
           .replace(/multiplied by/ig, '*')
           .replace(/times/ig, '*')
           .replace(/plus/ig, '+')
           .replace(/minus/ig, '-');

      // convert words for nth root
      s = s.replace(/(\d+)(st|nd|rd|th)?\s+root\s+of\s+/ig, function(_, n){ return 'nthRoot('; });
      // replace common verbal degree symbol
      s = s.replace(/°/g, 'deg');

      return s;
    }

    // stronger implicit multiplication handler:
    // handles: 2x, 2(x+1), )2 -> )*2, pi2 -> pi*2, xpi -> x*pi
    function applyImplicitMultiplication(expr) {
      let s = expr;

      // between number and letter or symbol: 2x -> 2*x
      s = s.replace(/(\d)(\s*)([A-Za-zπθ\(])/g, '$1*$3');

      // between letter/symbol and number or '(' : x2 -> x*2, x( -> x*(
      s = s.replace(/([A-Za-zπθ\)])(\s*)(\d|\()/g, '$1*$3');

      // specifically ensure pi and e stay as names: replace pi*pi -> pi*pi (no change)
      return s;
    }

    // utility: attempt to format result in fraction + decimal
    function formatFractionDecimal(val) {
      try {
        // numeric simple
        if (typeof val === 'number') {
          // integer check
          if (Math.abs(val - Math.round(val)) < 1e-12) return String(Math.round(val));
          // try rational approximation with limited denom
          const frac = math.fraction(val);
          // math.fraction may give huge denominators; keep reasonable
          if (Math.abs(frac.d) < 1000000) {
            return frac.n + '/' + frac.d + ' ≈ ' + Number.parseFloat(val.toPrecision(12)).toString();
          }
          return Number.parseFloat(val.toPrecision(12)).toString();
        }

        // math.js Fraction object
        if (math && math.typeOf && math.typeOf(val) === 'Fraction') {
          return val.s + (val.n + '/' + val.d);
        }

        // complex numbers
        if (typeof val === 'object' && val !== null && ('re' in val || 'im' in val)) {
          const re = ('re' in val) ? formatFractionDecimal(val.re) : '0';
          const im = ('im' in val) ? formatFractionDecimal(val.im) : '0';
          return re + (parseFloat(val.im) >= 0 ? ' + ' : ' - ') + Math.abs(val.im) + 'i';
        }

        return String(val);
      } catch (e) {
        return String(val);
      }
    }

    // ---------- Solving utilities ----------
    // try solving single equation for single variable using nerdamer, fallback numeric
    function solveSingleEquation(lhs, rhs) {
      const eqExpr = '(' + lhs + ')-(' + rhs + ')';
      // detect variables
      const varMatches = eqExpr.match(/[A-Za-zπθ]+/g) || [];
      const filtered = varMatches.filter(v => !['pi','e','i','deg'].includes(v.toLowerCase()));
      const variables = Array.from(new Set(filtered));
      if (variables.length === 0) {
        // numeric equality check
        try {
          const a = math.evaluate(lhs);
          const b = math.evaluate(rhs);
          return { type: 'bool', value: (Math.abs(a - b) < 1e-12) };
        } catch (e) {
          return { type: 'error', message: 'Unable to evaluate numeric equality.' };
        }
      }

      // pick first variable to solve for (user-friendly priority can be improved)
      const variable = variables[0];

      // try nerdamer symbolic solve
      try {
        // Use nerdamer to solve: nerdamer.solve(equation, variable) returns array-like
        const sols = nerdamer.solve(eqExpr, variable);
        // sols might be an expression or array; convert to readable strings
        if (Array.isArray(sols)) {
          return { type: 'symbolic', variable, solutions: sols.map(s => s.toString()) };
        } else {
          const sstr = sols.toString();
          return { type: 'symbolic', variable, solutions: [sstr] };
        }
      } catch (err) {
        // fallback: attempt numeric solve for linear equation using algebra.js or math.js
        try {
          // attempt algebra.js linear solve if possible
          if (algebra && algebra.parse) {
            // try form: ax + b = c  -> use algebra to rearrange
            // (This is a simple attempt; complex symbolic fallback is handled above)
            const eq = algebra.parse(lhs + ' - (' + rhs + ')');
            const simplified = eq.simplify(); // algebra.js expression
            // algebra.js Solve not always available; skip heavy logic here
            return { type: 'error', message: 'Symbolic solve failed; try simpler form.' };
          } else {
            return { type: 'error', message: 'Solve unavailable.' };
          }
        } catch (e) {
          return { type: 'error', message: 'Solve failed.' };
        }
      }
    }

    // try solving system of equations (simple linear systems) using numeric linear algebra
    function solveSystem(equations) {
      // equations: array of strings, like ["x+y=5","x-y=1"]
      try {
        // parse variables
        const varSet = new Set();
        equations.forEach(eq => {
          const toks = (eq.match(/[A-Za-zπθ]+/g) || []);
          toks.forEach(t => { if (!['pi','e','i','deg'].includes(t.toLowerCase())) varSet.add(t); });
        });
        const vars = Array.from(varSet);
        if (vars.length === 0) return { type: 'error', message: 'No variables found' };

        // build linear system matrix A*x = b for only linear coefficients (best-effort)
        const A = [];
        const b = [];
        for (let eq of equations) {
          // split on '='
          const parts = eq.split('=');
          if (parts.length !== 2) return { type: 'error', message: 'Invalid equation in system' };
          const lhs = math.simplify(parts[0]);
          const rhs = math.simplify(parts[1]);

          // create coefficient row
          const row = vars.map(v => {
            // coefficient of v in lhs
            try {
              // use derivative trick: coeff = derivative(lhs, v) evaluated at 0? crude approach
              // Better: use algebraic expansion and coefficient extraction via nerdamer
              const coeffExpr = nerdamer('coeff(' + parts[0] + ',' + v + ')').evaluate().text();
              const c = parseFloat(coeffExpr);
              return isNaN(c) ? 0 : c;
            } catch (e) {
              return 0;
            }
          });

          // constant term b = rhs - remaining terms
          try {
            const rhsVal = math.evaluate(parts[1]);
            b.push(rhsVal);
          } catch (e) {
            b.push(0);
          }
          A.push(row);
        }

        // numeric solve A*x = b
        const matA = math.matrix(A);
        const vecB = math.matrix(b);
        const solution = math.lusolve(matA, vecB); // returns matrix
        const solObj = {};
        for (let i = 0; i < vars.length; i++) {
          solObj[vars[i]] = solution.get([i, 0]);
        }
        return { type: 'system', solution: solObj };
      } catch (err) {
        return { type: 'error', message: 'System solve failed: ' + err.message };
      }
    }

    // ---------- Message handler for keyboard iframe ----------
    window.addEventListener('message', function(e) {
      try {
        const data = e.data;
        if (!data || !data.type) return;
        if (data.type === 'keyPress') {
          // insert at cursor
          const el = document.getElementById('expression');
          const start = el.selectionStart || el.value.length;
          const end = el.selectionEnd || el.value.length;
          const before = el.value.slice(0, start);
          const after = el.value.slice(end);
          el.value = before + data.value + after;
          const newPos = before.length + data.value.length;
          el.selectionStart = el.selectionEnd = newPos;
          el.focus();
        } else if (data.type === 'command' && data.name === 'solve') {
          solveExpression();
        }
      } catch (err) {
        console.warn('Keyboard message handler error', err);
      }
    });

    // ---------- High-level solve entry that uses the helpers above ----------
    function solveExpression() {
      const raw = document.getElementById('expression').value || '';
      const out = document.getElementById('output');
      out.innerHTML = '...computing...';

      // quick sanitize / natural language normalization
      let s = normalizeNaturalLanguage(raw);
      s = preprocessInput(s);
      s = applyImplicitMultiplication(s);

      // timebox heavy computations (very large symbolic tasks)
      let finished = false;
      try {
        // if system of equations detected (multiple '=' on lines or semicolons)
        const lines = s.split(/\\n|;/).map(l => l.trim()).filter(Boolean);
        const eqLines = lines.filter(l => l.includes('='));
        if (eqLines.length > 1) {
          // system solving
          const sysRes = solveSystem(eqLines);
          if (sysRes.type === 'system') {
            out.innerHTML = '<b>System solution:</b><br>' + JSON.stringify(sysRes.solution, null, 2);
          } else {
            out.innerHTML = '⚠️ ' + sysRes.message;
          }
          finished = true;
        } else if (s.includes('=')) {
          // single equation
          const [lhs, rhs] = s.split('=');
          const sol = solveSingleEquation(lhs, rhs);
          if (sol.type === 'symbolic') {
            out.innerHTML = '<b>Variable:</b> ' + sol.variable + '<br><b>Solutions:</b><br>' + sol.solutions.join('<br>');
          } else if (sol.type === 'bool') {
            out.innerHTML = sol.value ? '✅ True equation' : '❌ False equation';
          } else {
            out.innerHTML = '⚠️ ' + sol.message;
          }
          finished = true;
        } else {
          // evaluate expression: try math.evaluate, if error, try nerdamer simplify
          try {
            const val = math.evaluate(s);
            out.innerHTML = '<b>Result:</b><br>' + formatFractionDecimal(val);
            finished = true;
          } catch (e) {
            // fallback to nerdamer simplify
            try {
              const simp = nerdamer(s).toString();
              out.innerHTML = '<b>Simplified:</b><br>' + simp;
              finished = true;
            } catch (ee) {
              out.innerHTML = '⚠️ Could not evaluate expression';
              finished = true;
            }
          }
        }
      } catch (err) {
        out.innerHTML = '❌ Error while solving: ' + err.message;
        finished = true;
      }

      if (!finished) out.innerHTML = '⚠️ Computation did not finish.';
    }
    <script>
    // ---------- Extra parsing for roots, decimals, trig, factorials ----------

    // handle √, nthRoot, fractional exponents
    function handleRoots(expr) {
      let s = expr;
      // √x -> sqrt(x)
      s = s.replace(/√\s*([A-Za-z0-9\(\)]+)/g, 'sqrt($1)');
      // nthRoot(n,x) stays as is
      // convert ^(1/n) to nthRoot(n,...)
      s = s.replace(/\(([^)]+)\)\s*\^\s*\(1\/(\d+)\)/g, 'nthRoot($2,$1)');
      return s;
    }

    // handle repeating decimals with overline notation, e.g. 0.\overline{3}
    function handleRepeatingDecimals(expr) {
      let s = expr;
      // convert LaTeX-like: 0.\overline{3}
      s = s.replace(/(\d*)\.\s*\\overline\{(\d+)\}/g, function(_, intPart, rep){
        const intVal = intPart === '' ? 0 : parseInt(intPart,10);
        const repLen = rep.length;
        const numerator = intVal * (Math.pow(10, repLen) - 1) + parseInt(rep,10);
        const denominator = Math.pow(10, repLen) - 1;
        return '('+numerator+'/'+denominator+')';
      });
      return s;
    }

    // handle trig with degrees: sin30°, cos(45°), tan(π/6)
    function handleTrigDegrees(expr) {
      let s = expr;
      // detect number followed by ° inside sin(), cos(), tan()
      s = s.replace(/(sin|cos|tan|cot|sec|csc)\s*\(\s*([0-9\.]+)\s*°\s*\)/g, function(_, fn, deg){
        const rad = (parseFloat(deg) * Math.PI / 180).toFixed(12);
        return fn+'('+rad+')';
      });
      // plain 30° outside functions -> (30*pi/180)
      s = s.replace(/([0-9\.]+)\s*°/g, function(_, deg){
        const rad = (parseFloat(deg) * Math.PI / 180).toFixed(12);
        return '('+rad+')';
      });
      return s;
    }

    // handle factorial: n! -> factorial(n), with safe bound
    function handleFactorial(expr) {
      let s = expr;
      s = s.replace(/(\d+|\([^\)]+\))!/g, function(_, n){
        return 'factorial('+n+')';
      });
      return s;
    }

    // override factorial to prevent huge blowups
    function factorial(n) {
      n = Math.floor(Number(n));
      if (isNaN(n) || n < 0) throw new Error("Invalid factorial input");
      if (n > 170) throw new Error("Factorial too large (n>170)");
      let res = 1;
      for (let i=2; i<=n; i++) res *= i;
      return res;
    }

    // ---------- Calculus features ----------
    function derivativeOf(expr, variable) {
      try {
        const d = nerdamer('diff(' + expr + ',' + variable + ')');
        return d.toString();
      } catch (e) {
        return '❌ Derivative failed: ' + e.message;
      }
    }

    function integralOf(expr, variable) {
      try {
        const i = nerdamer('integrate(' + expr + ',' + variable + ')');
        return i.toString();
      } catch (e) {
        return '❌ Integral failed: ' + e.message;
      }
    }

    // ---------- Pretty-printing output ----------
    function prettyPrintResult(label, value) {
      return '<div class="result-block"><b>'+label+':</b><br>'+value+'</div>';
    }

    // extend solveExpression to use new preprocess steps
    const oldSolve = solveExpression;
    solveExpression = function() {
      const raw = document.getElementById('expression').value || '';
      const out = document.getElementById('output');
      out.innerHTML = '...computing...';

      let s = normalizeNaturalLanguage(raw);
      s = preprocessInput(s);
      s = applyImplicitMultiplication(s);
      s = handleRoots(s);
      s = handleRepeatingDecimals(s);
      s = handleTrigDegrees(s);
      s = handleFactorial(s);

      try {
        // detect derivative command: d/dx(...)
        if (/^d\/d([a-zA-Z])\(/.test(s)) {
          const m = s.match(/^d\/d([a-zA-Z])\((.+)\)$/);
          if (m) {
            const variable = m[1];
            const expr = m[2];
            const result = derivativeOf(expr, variable);
            out.innerHTML = prettyPrintResult('Derivative wrt '+variable, result);
            return;
          }
        }
        // detect integral command: ∫(...,dx)
        if (/^∫\((.+),d([a-zA-Z])\)$/.test(s)) {
          const m = s.match(/^∫\((.+),d([a-zA-Z])\)$/);
          if (m) {
            const expr = m[1];
            const variable = m[2];
            const result = integralOf(expr, variable);
            out.innerHTML = prettyPrintResult('Integral wrt '+variable, result);
            return;
          }
        }
      } catch (e) {
        out.innerHTML = '❌ Parsing error: '+e.message;
        return;
      }

      // fallback to old solver pipeline
      oldSolve.call(this);
    };
  </script>                                     </script>
<!-- ================= CONTINUATION FROM LINE ~401 ================= -->

<script>
// --- Fix for bar notation (repeating decimals like 31.69̅ or 31̅69) ---

// Helper: Convert repeating decimal string to fraction
function repeatingDecimalToFraction(nonRepeating, repeating) {
    // Example: 31.69 with bar over "69"
    const base = nonRepeating || "0";
    const repeat = repeating || "";

    if (repeat.length === 0) {
        return math.fraction(parseFloat(base)); // nothing repeating
    }

    const fullNumber = base + repeat;
    const lenNonRep = base.length;
    const lenRep = repeat.length;

    // numerator = fullNumber - nonRepeatingPart
    const num1 = BigInt(fullNumber.replace(".", ""));
    const num2 = BigInt(base.replace(".", "") || "0");

    const numerator = num1 - num2;
    const denominator = BigInt("9".repeat(lenRep) + "0".repeat(lenNonRep - (base.includes(".") ? base.split(".")[1].length : 0)));

    return math.fraction(Number(numerator), Number(denominator));
}

// Parser upgrade: detect bar notation like 31.69bar or 31bar69
function handleBarNotation(expr) {
    // Match patterns like: 31.69bar  or  31bar69
    return expr.replace(/(\d*\.\d+|\d+)bar(\d+)/g, (_, nonRep, rep) => {
        try {
            const frac = repeatingDecimalToFraction(nonRep, rep);
            return `(${math.format(frac, {fraction: "ratio"})})`;
        } catch (e) {
            console.error("Bar parse failed:", e);
            return "NaN";
        }
    });
}

// --- Override preprocessInput to include bar handling ---
const oldPreprocessInput = preprocessInput;
preprocessInput = function(input) {
    let expr = input;

    // Handle bar notation first
    expr = handleBarNotation(expr);

    // Fall back to old logic
    expr = oldPreprocessInput(expr);
    return expr;
};

// --- Testing hook ---
window.testBarCases = function() {
    console.log("31.69bar =>", preprocessInput("31.69bar"));
    console.log("31bar69 =>", preprocessInput("31bar69"));
};
</script>

<!-- ================= END OF 401–500 ================= -->
<!-- ================= CONTINUATION FROM LINE ~501 ================= -->

<script>
// --- Extend bar handling to show fraction + decimal output ---

function formatResultWithBar(expr, result) {
    // Detect if input had 'bar'
    if (!/bar/.test(expr)) return result;

    try {
        // Convert original expression again for fraction form
        const match = expr.match(/(\d*\.\d+|\d+)bar(\d+)/);
        if (match) {
            const nonRep = match[1];
            const rep = match[2];
            const frac = repeatingDecimalToFraction(nonRep, rep);

            const decimalVal = math.number(frac);
            const fractionStr = math.format(frac, {fraction: "ratio"});
            const decimalStr = decimalVal.toString();

            return `${fractionStr} ≈ ${decimalStr}`;
        }
    } catch (e) {
        console.warn("Bar display error:", e);
    }
    return result;
}

// --- Override displayResult so bar notation outputs both ---
const oldDisplayResult = displayResult;
displayResult = function(input, result) {
    let output = result;

    // Special formatting for bar cases
    output = formatResultWithBar(input, output);

    // Call the original display function
    oldDisplayResult(input, output);
};

// --- Testing hook ---
window.testBarDisplay = function() {
    displayResult("31.69bar", preprocessInput("31.69bar"));
    displayResult("31bar69", preprocessInput("31bar69"));
};
</script>

<!-- ================= END OF 501–600 ================= -->
<!-- ================= Lines 601–700 ================= -->

<script>
// --- BAR NOTATION HANDLER (repeating decimals) ---
function parseRepeatingDecimal(input) {
    // Matches forms like 12.(34) or 0.(9)
    const regex = /^(\d*)\.?(\d*)\((\d+)\)$/;
    const match = input.match(regex);

    if (!match) return null;

    let intPart = match[1] || "0";
    let nonRepeat = match[2] || "";
    let repeat = match[3];

    // Construct fraction formula
    let fullNumber = intPart + (nonRepeat ? "." + nonRepeat : "");
    let nonRepeatLen = nonRepeat.length;
    let repeatLen = repeat.length;

    let base = BigInt(intPart + (nonRepeat || "0"));
    let nonRepVal = nonRepeat ? BigInt(nonRepeat) : 0n;
    let repVal = BigInt(repeat);

    let numerator = BigInt(intPart + nonRepeat) * (BigInt(10) ** BigInt(repeatLen)) + repVal
                    - BigInt(intPart + (nonRepeat || "0"));
    let denominator = (BigInt(10) ** BigInt(nonRepeatLen + repeatLen)) 
                    - (BigInt(10) ** BigInt(nonRepeatLen));

    // Simplify fraction
    function gcd(a, b) { return b === 0n ? a : gcd(b, a % b); }
    let g = gcd(numerator, denominator);
    numerator /= g;
    denominator /= g;

    return {
        fraction: numerator.toString() + "/" + denominator.toString(),
        decimal: (Number(numerator) / Number(denominator)).toString()
    };
}

// --- INTERCEPT INPUT ---
function handleBarInput(expr) {
    const result = parseRepeatingDecimal(expr.trim());
    if (result) {
        displayResult(expr, result.fraction, result.decimal);
        return true;
    }
    return false;
}

// --- DISPLAY BOTH FRACTION + DECIMAL ---
function displayResult(expr, fraction, decimal) {
    const output = document.getElementById("solver-output");
    output.innerHTML = `
        <div class="result-block">
            <strong>Input:</strong> ${expr} <br>
            <strong>Fraction:</strong> ${fraction} <br>
            <strong>Decimal:</strong> ${decimal}
        </div>
    `;
}
</script>

<!-- --- USER NOTES SECTION --- -->
<div id="notes-section" style="margin-top:20px; padding:15px; background:#f5f5f5; border-radius:10px;">
    <h3>📘 How to Use the Solver</h3>
    <ul>
        <li>You can type normal math expressions: <code>2+3*5</code></li>
        <li>Use brackets () to keep order of operations.</li>
        <li>For roots: <code>sqrt(25)</code> or <code>nthRoot(27,3)</code></li>
        <li>For trigonometry: <code>sin(30 deg)</code> or <code>cos(pi/3)</code></li>
        <li>For factorial: <code>5!</code></li>
        <li>For derivatives: <code>derivative(x^2, x)</code></li>
        <li>For integrals: <code>integrate(x^2, x)</code></li>
        <li><strong>Using the Bar Key (Repeating Decimals):</strong><br>
            - Type number normally, then put repeating part in brackets.<br>
            - Example: <code>31.(69)</code> means 31.696969...<br>
            - Example: <code>31.6(9)</code> means 31.699999...<br>
            - Solver will show both <em>fraction</em> and <em>decimal</em> forms.<br>
        </li>
    </ul>
</div>
<!-- ===============================
         Lines 701–800 of solver.html
         =============================== -->

    <script>
      /***********************
       * BAR KEY HANDLING
       ***********************/
      // Preprocess "bar" notation into repeating decimal
      function handleBarNotation(expr) {
        // Match forms like: 31.bar69  OR  0.bar3
        return expr.replace(/(\d*)\.?bar(\d+)/gi, (match, intPart, repeatPart) => {
          if (!repeatPart) return match;
          const integer = intPart || "0";
          const nonRepeat = ""; // for now only pure repeating decimals
          const repLength = repeatPart.length;

          // Convert repeating decimal to fraction
          // Example: 0.bar3 = 1/3, 31.bar69 = (3169-31)/(99) etc.
          let numerator =
            parseInt(integer + repeatPart) - parseInt(integer + nonRepeat || integer);
          let denominator = Math.pow(10, nonRepeat.length + repLength) - Math.pow(10, nonRepeat.length);

          let frac = nerdamer(`(${numerator})/(${denominator})`).toString();
          return `(${frac})`;
        });
      }

      /***********************
       * PREPROCESS INPUT
       ***********************/
      function preprocessInput(input) {
        let expr = input.trim();

        // Handle bar key before sending to solvers
        expr = handleBarNotation(expr);

        // Convert implicit multiplication: 2x -> 2*x
        expr = expr.replace(/(\d)([a-zA-Z])/g, "$1*$2");

        // Convert ^ to pow()
        expr = expr.replace(/(\w+)\^(\w+)/g, "pow($1,$2)");

        return expr;
      }

      /***********************
       * SOLVE + DISPLAY BOTH FORMS
       ***********************/
      function solveAndDisplay(input) {
        try {
          const pre = preprocessInput(input);

          // Try nerdamer first
          let result;
          try {
            result = nerdamer(pre).evaluate().toString();
          } catch (e) {
            // fallback to math.js
            result = math.evaluate(pre);
          }

          // Show both fraction and decimal if possible
          let fractionForm = result;
          let decimalForm = "";

          try {
            fractionForm = nerdamer(result).toString();
            decimalForm = math.format(math.evaluate(result), { precision: 10 });
          } catch (err) {
            // only decimal possible
            decimalForm = result;
          }

          document.getElementById("output").innerHTML =
            `<b>Answer:</b> ${fractionForm}` +
            (decimalForm && fractionForm !== decimalForm
              ? ` ≈ ${decimalForm}`
              : "");
        } catch (err) {
          document.getElementById("output").innerHTML =
            `<span style="color:red;">Invalid input: ${err.message}</span>`;
        }
      }

      /***********************
       * NOTE SECTION
       ***********************/
      window.addEventListener("DOMContentLoaded", () => {
        const notes = document.createElement("div");
        notes.className = "solver-notes";
        notes.style.marginTop = "20px";
        notes.innerHTML = `
          <h3>📌 Notes for Students:</h3>
          <ul>
            <li>Always try to use brackets () to make expressions clear.  
                Example: write (2/3)*x instead of 2/3x.</li>
            <li>You can type <b>bar</b> after digits to represent repeating decimals.  
                Example: <code>0.bar3</code> → 1/3, <code>31.bar69</code> → 31.696969…</li>
            <li>The solver shows answers in both fraction and decimal form automatically.</li>
            <li>Supports algebra, equations, inequalities, roots, trigonometry, calculus, and more.</li>
            <li>If the expression is too complex, you may see a simplified result or scientific notation.</li>
          </ul>
        `;
        document.body.appendChild(notes);
      });
                              </script>
<!-- ===============================
         Lines 801–900 of solver.html
         =============================== -->

    <script>
      /***********************
       * INEQUALITIES HANDLER
       ***********************/
      function solveInequality(expr) {
        try {
          // Nerdamer can sometimes handle inequalities if rearranged
          if (expr.includes("<") || expr.includes(">")) {
            // Split inequality into LHS and RHS
            let match = expr.match(/(.+?)(<=|>=|<|>)(.+)/);
            if (match) {
              let lhs = preprocessInput(match[1]);
              let op = match[2];
              let rhs = preprocessInput(match[3]);

              // Convert to standard form lhs - rhs
              let testExpr = `${lhs} - (${rhs})`;
              let testVal = math.evaluate(testExpr);

              return `Inequality: ${lhs} ${op} ${rhs}  → ${testVal} ${op} 0`;
            }
          }
          return null;
        } catch (err) {
          return `Could not process inequality: ${err.message}`;
        }
      }

      /***********************
       * SYSTEM OF EQUATIONS
       ***********************/
      function solveSystem(equations) {
        try {
          let parsed = equations.map(preprocessInput);
          let vars = new Set();

          // Collect variables
          parsed.forEach(eq => {
            let found = eq.match(/[a-zA-Z]+/g);
            if (found) found.forEach(v => vars.add(v));
          });

          vars = Array.from(vars);

          if (parsed.length > 1) {
            let sol = nerdamer.solveEquations(parsed);
            return JSON.stringify(sol);
          } else {
            return "Provide at least 2 equations for a system.";
          }
        } catch (err) {
          return `Error solving system: ${err.message}`;
        }
      }

      /***********************
       * FACTORIAL & COMBINATORICS
       ***********************/
      function solveFactorial(expr) {
        try {
          if (expr.includes("!")) {
            let clean = preprocessInput(expr);
            let result = math.evaluate(clean);
            return `${expr} = ${result}`;
          }
          return null;
        } catch (err) {
          return `Factorial error: ${err.message}`;
        }
      }

      /***********************
       * DERIVATIVE & INTEGRAL
       ***********************/
      function solveCalculus(expr) {
        try {
          if (expr.startsWith("diff(")) {
            let res = nerdamer(expr).toString();
            return `Derivative: ${res}`;
          }
          if (expr.startsWith("integrate(")) {
            let res = nerdamer(expr).toString();
            return `Integral: ${res}`;
          }
          return null;
        } catch (err) {
          return `Calculus error: ${err.message}`;
        }
      }

      /***********************
       * MAIN SOLVER DISPATCH
       ***********************/
      function universalSolver(input) {
        let expr = input.trim();

        // Try inequalities
        let ineq = solveInequality(expr);
        if (ineq) return ineq;

        // Try factorial
        let fact = solveFactorial(expr);
        if (fact) return fact;

        // Try calculus
        let calc = solveCalculus(expr);
        if (calc) return calc;

        // System of equations (split by ;)
        if (expr.includes(";")) {
          let parts = expr.split(";").map(e => e.trim());
          return solveSystem(parts);
        }

        // Default solver
        try {
          return nerdamer(expr).toString();
        } catch (e) {
          try {
            return math.evaluate(expr);
          } catch (err) {
            return `❌ Invalid input: ${err.message}`;
          }
        }
      }

      /***********************
       * BIND SOLVE BUTTON
       ***********************/
      window.addEventListener("DOMContentLoaded", () => {
        const btn = document.getElementById("solveBtn");
        const inp = document.getElementById("mathInput");
        const out = document.getElementById("output");

        btn.addEventListener("click", () => {
          out.innerHTML = `<i>Processing...</i>`;
          setTimeout(() => {
            let result = universalSolver(inp.value);
            out.innerHTML = `<b>Result:</b> ${result}`;
          }, 200);
        });
      });
    </script>
<!-- ===============================
     Lines 901–1000 of solver.html
     (polish, keyboard glue, tests, responsiveness)
     =============================== -->

<script>
  /***********************
   * Helper: find input & output elements robustly
   ***********************/
  function getInputEl() {
    return document.getElementById('expression') 
        || document.getElementById('user-input')
        || document.getElementById('mathInput')
        || document.querySelector('textarea') 
        || null;
  }
  function getOutputEl() {
    return document.getElementById('output') 
        || document.getElementById('solver-output') 
        || document.getElementById('result') 
        || document.querySelector('.output')
        || null;
  }
  function getSolveBtn() {
    return document.getElementById('solveBtn') 
        || document.querySelector('button[onclick="solveExpression()"]') 
        || document.querySelector('button[onclick="solveMath()"]') 
        || document.querySelector('button');
  }

  /***********************
   * Keyboard iframe listener (robust)
   * Accepts message { type: 'keyPress', value: 'sin(' } or { type: 'command', name:'solve' }
   ***********************/
  window.addEventListener('message', (event) => {
    try {
      const data = event.data;
      if (!data || typeof data !== 'object') return;
      const inputEl = getInputEl();
      if (!inputEl) return;

      if (data.type === 'keyPress' && typeof data.value === 'string') {
        const start = inputEl.selectionStart || inputEl.value.length;
        const end = inputEl.selectionEnd || start;
        inputEl.value = inputEl.value.slice(0, start) + data.value + inputEl.value.slice(end);
        const pos = start + data.value.length;
        inputEl.selectionStart = inputEl.selectionEnd = pos;
        inputEl.focus();
      } else if (data.type === 'command' && data.name === 'solve') {
        // prefer universalSolver if available, fallback to solveExpression / solveMath
        const cur = inputEl.value;
        if (typeof universalSolver === 'function') {
          const out = getOutputEl();
          out && (out.innerHTML = '<i>Processing...</i>');
          setTimeout(() => {
            const res = universalSolver(cur);
            out && (out.innerHTML = `<b>Result:</b> ${res}`);
          }, 80);
        } else if (typeof solveExpression === 'function') {
          solveExpression();
        } else if (typeof solveMath === 'function') {
          solveMath();
        }
      }
    } catch (err) {
      console.warn('Keyboard message error', err);
    }
  });

  /***********************
   * Mobile / responsive tweaks
   ***********************/
  (function makeResponsive() {
    const style = document.createElement('style');
    style.innerHTML = `
      @media (max-width: 600px) {
        textarea { font-size: 16px; height: 120px; }
        button { width: 48%; margin-bottom: 8px; }
        .container { padding: 12px; }
      }
      .result-block { margin: 8px 0; padding:8px; background:#fff; border-radius:6px; border:1px solid #eee; }
    `;
    document.head.appendChild(style);
  })();

  /***********************
   * Self-test suite (quick checks)
   ***********************/
  window.runSolverSelfTests = function() {
    const out = getOutputEl();
    const i = getInputEl();
    const tests = [
      { in: 'a+26=56', want: 'a' },
      { in: 'x+5=8', want: '3' },
      { in: 'x^2-5x+6=0', want: '2' }, // expect roots 2 and 3
      { in: 'sqrt9', want: '3' },
      { in: '31.(69)', want: '31.6969' },
      { in: '0.bar3', want: '1/3' }
    ];
    let results = [];
    for (let t of tests) {
      try {
        i.value = t.in;
        let res;
        if (typeof universalSolver === 'function') res = universalSolver(t.in);
        else if (typeof solveExpression === 'function') { solveExpression(); res = (out && out.innerText) || ''; }
        else if (typeof solveMath === 'function') { solveMath(); res = (out && out.innerText) || ''; }
        results.push({ test: t.in, got: String(res).slice(0,30) });
      } catch (e) {
        results.push({ test: t.in, error: e.message });
      }
    }
    console.table(results);
    alert('Self-tests completed — open console for details.');
  };

  /***********************
   * Accessibility: keyboard shortcut (Ctrl+Enter) to solve
   ***********************/
  (function bindShortcuts() {
    const input = getInputEl();
    if (!input) return;
    input.addEventListener('keydown', (ev) => {
      if ((ev.ctrlKey || ev.metaKey) && ev.key === 'Enter') {
        ev.preventDefault();
        // trigger solve
        const btn = getSolveBtn();
        if (btn) btn.click();
        else {
          if (typeof universalSolver === 'function') {
            const out = getOutputEl();
            out && (out.innerHTML = '<i>Processing...</i>');
            setTimeout(() => {
              const res = universalSolver(input.value);
              out && (out.innerHTML = `<b>Result:</b> ${res}`);
            }, 80);
          } else if (typeof solveExpression === 'function') solveExpression();
        }
      }
    });
  })();

  /***********************
   * Final small helper: ensure no accidental HTML close
   ***********************/
  console.log('UniversalSolver lines up to ~1000 loaded. Keep pasting further chunks without closing HTML.');
</script>
