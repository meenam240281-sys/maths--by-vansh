<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Graphs</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f5f6fa;
      color: #333;
    }
    nav {
      background: #2f3640;
      padding: 10px;
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    nav a {
      color: white;
      text-decoration: none;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    .container {
      padding: 20px;
      text-align: center;
    }
    canvas {
      border: 1px solid #ccc;
      background: white;
      touch-action: none; /* stop whole-page zoom on touch */
    }
    input, button {
      padding: 6px;
      margin: 5px;
    }
  </style>
</head>
<body>
  <nav>
    <a href="index.html">HOME</a>
    <a href="resources.html">RESOURCES</a>
    <a href="contact.html">CONTACT</a>
    <a href="solver.html">MATH SOLVER</a>
    <a href="graphs.html">GRAPH</a>
  </nav>

  <div class="container">
    <h2>Interactive Graph</h2>
    <input type="text" id="equation" placeholder="Enter equation or point e.g. y=x^2 or (2,3)">
    <button onclick="plot()">Plot</button>
    <br><br>
    <canvas id="graphCanvas" width="800" height="500"></canvas>
  </div>

  <script>
    const canvas = document.getElementById("graphCanvas");
    const ctx = canvas.getContext("2d");

    // Graph state
    let scale = 40; // pixels per unit
    let offsetX = canvas.width / 2;
    let offsetY = canvas.height / 2;
    let isDragging = false;
    let dragStart = {};

    const colors = ["#e67e22", "#8e44ad", "#27ae60", "#c0392b", "#2980b9"];
    let plots = [];

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Grid spacing depends on zoom
      let step = 1;
      if (scale < 20) step = 5;
      if (scale < 10) step = 10;

      ctx.strokeStyle = "#ddd";
      ctx.lineWidth = 1;

      // vertical lines
      for (let x = offsetX % (scale * step); x <= canvas.width; x += scale * step) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }

      // horizontal lines
      for (let y = offsetY % (scale * step); y <= canvas.height; y += scale * step) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = "black";
      ctx.beginPath();
      ctx.moveTo(0, offsetY);
      ctx.lineTo(canvas.width, offsetY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(offsetX, 0);
      ctx.lineTo(offsetX, canvas.height);
      ctx.stroke();

      // Numbers
      ctx.fillStyle = "black";
      ctx.font = "12px Arial";
      for (let x = offsetX % (scale * step); x <= canvas.width; x += scale * step) {
        const val = Math.round((x - offsetX) / scale);
        ctx.fillText(val, x + 2, offsetY + 12);
      }
      for (let y = offsetY % (scale * step); y <= canvas.height; y += scale * step) {
        const val = -Math.round((y - offsetY) / scale);
        if (val !== 0) ctx.fillText(val, offsetX + 4, y - 2);
      }
    }

    function drawPlots() {
      plots.forEach((plot, i) => {
        ctx.strokeStyle = colors[i % colors.length];
        ctx.fillStyle = colors[i % colors.length];

        if (plot.type === "equation") {
          ctx.beginPath();
          let first = true;
          for (let px = 0; px < canvas.width; px++) {
            let x = (px - offsetX) / scale;
            let y;
            try {
              y = eval(plot.expr.replace(/x/g, `(${x})`));
            } catch {
              continue;
            }
            let py = offsetY - y * scale;
            if (first) {
              ctx.moveTo(px, py);
              first = false;
            } else {
              ctx.lineTo(px, py);
            }
          }
          ctx.stroke();
        } else if (plot.type === "point") {
          let px = offsetX + plot.x * scale;
          let py = offsetY - plot.y * scale;
          ctx.beginPath();
          ctx.arc(px, py, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    function redraw() {
      drawGrid();
      drawPlots();
    }

    function plot() {
      const input = document.getElementById("equation").value.trim();
      if (!input) return;

      if (input.startsWith("(") && input.endsWith(")")) {
        // Point
        let coords = input.slice(1, -1).split(",");
        let x = parseFloat(coords[0]);
        let y = parseFloat(coords[1]);
        plots.push({ type: "point", x, y });
      } else {
        // Equation
        let expr = input.replace("^", "**");
        plots.push({ type: "equation", expr });
      }
      document.getElementById("equation").value = "";
      redraw();
    }

    // Dragging
    canvas.addEventListener("mousedown", e => {
      isDragging = true;
      dragStart.x = e.clientX - offsetX;
      dragStart.y = e.clientY - offsetY;
    });
    canvas.addEventListener("mousemove", e => {
      if (isDragging) {
        offsetX = e.clientX - dragStart.x;
        offsetY = e.clientY - dragStart.y;
        redraw();
      }
    });
    canvas.addEventListener("mouseup", () => isDragging = false);
    canvas.addEventListener("mouseleave", () => isDragging = false);

    // Touch drag
    canvas.addEventListener("touchstart", e => {
      if (e.touches.length === 1) {
        isDragging = true;
        dragStart.x = e.touches[0].clientX - offsetX;
        dragStart.y = e.touches[0].clientY - offsetY;
      }
    });
    canvas.addEventListener("touchmove", e => {
      if (e.touches.length === 1 && isDragging) {
        offsetX = e.touches[0].clientX - dragStart.x;
        offsetY = e.touches[0].clientY - dragStart.y;
        redraw();
      }
    });
    canvas.addEventListener("touchend", () => isDragging = false);

    // Zoom
    canvas.addEventListener("wheel", e => {
      e.preventDefault();
      const zoom = e.deltaY < 0 ? 1.1 : 0.9;
      scale *= zoom;
      redraw();
    });

    redraw();
  </script>
</body>
</html>
