<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graphs</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f8f9fa; }
  header { background: #34495e; color: white; padding: 1rem; text-align: center; }
  h1 { margin: 0; font-size: 1.8rem; }
  #inputSection { padding: 1rem; text-align: center; }
  input[type=text] { width: 80%; padding: 0.5rem; font-size: 1rem; }
  button { padding: 0.5rem 1rem; font-size: 1rem; margin-left: 0.5rem; cursor: pointer; }
  #graphContainer { width: 100%; height: 70vh; background: white; margin-top: 1rem; border: 1px solid #ccc; }
</style>
</head>
<body>
<header>
  <h1>Graphs</h1>
</header>

<div id="inputSection">
  <input type="text" id="graphInput" placeholder="Enter points (x,y) or equations y=f(x), separated by ;">
  <button onclick="plotGraph()">Plot</button>
</div>

<div id="graphContainer">
  <canvas id="graphCanvas" width="800" height="500"></canvas>
</div>

<script>
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");

let scale = 40; // pixels per unit
let offsetX = canvas.width / 2;
let offsetY = canvas.height / 2;
let colors = ["orange", "purple", "green", "blue", "red", "brown", "magenta", "teal", "cyan"];
let equations = [];

function drawAxes() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = "#aaa";
  ctx.lineWidth = 1;

  // vertical lines
  for (let x = 0; x <= canvas.width; x += scale) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  // horizontal lines
  for (let y = 0; y <= canvas.height; y += scale) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // axes
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;
  // x-axis
  ctx.beginPath();
  ctx.moveTo(0, offsetY);
  ctx.lineTo(canvas.width, offsetY);
  ctx.stroke();
  // y-axis
  ctx.beginPath();
  ctx.moveTo(offsetX, 0);
  ctx.lineTo(offsetX, canvas.height);
  ctx.stroke();

  // numbers
  ctx.fillStyle = "#000";
  ctx.font = "12px Arial";
  for (let i = -Math.floor(offsetX/scale); i <= Math.floor(offsetX/scale); i++) {
    if(i!==0) ctx.fillText(i, offsetX + i*scale - 5, offsetY + 12);
  }
  for (let i = -Math.floor(offsetY/scale); i <= Math.floor(offsetY/scale); i++) {
    if(i!==0) ctx.fillText(-i, offsetX + 2, offsetY + i*scale + 4);
  }
}

function plotGraph() {
  drawAxes();
  const input = document.getElementById("graphInput").value;
  if(!input) return;
  equations = input.split(";").map(s => s.trim());

  equations.forEach((eq, idx) => {
    const color = colors[idx % colors.length];
    ctx.strokeStyle = color;
    ctx.fillStyle = color;

    if(eq.match(/^\([^)]+\)$/)) { // point (x,y)
      const coords = eq.replace(/[()]/g,"").split(",");
      const x = parseFloat(coords[0]);
      const y = parseFloat(coords[1]);
      ctx.beginPath();
      ctx.arc(offsetX + x*scale, offsetY - y*scale, 4, 0, Math.PI*2);
      ctx.fill();
    } else { // equation y=f(x)
      ctx.beginPath();
      let first = true;
      for(let px = -offsetX/scale; px < (canvas.width-offsetX)/scale; px += 0.01) {
        let y = 0;
        try {
          y = eval(eq.replace(/x/g, `(${px})`));
        } catch(e) { continue; }
        const cx = offsetX + px*scale;
        const cy = offsetY - y*scale;
        if(first) { ctx.moveTo(cx, cy); first=false; }
        else { ctx.lineTo(cx, cy); }
      }
      ctx.stroke();
    }
  });
}

// basic zoom and drag
let isDragging = false;
let startX, startY;
canvas.addEventListener("mousedown", e => { isDragging=true; startX=e.offsetX; startY=e.offsetY; });
canvas.addEventListener("mouseup", e => { isDragging=false; });
canvas.addEventListener("mousemove", e => {
  if(!isDragging) return;
  const dx = e.offsetX - startX;
  const dy = e.offsetY - startY;
  offsetX += dx;
  offsetY += dy;
  startX = e.offsetX;
  startY = e.offsetY;
  plotGraph();
});
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoom = e.deltaY < 0 ? 1.1 : 0.9;
  scale *= zoom;
  plotGraph();
});

drawAxes();
</script>
</body>
</html>
